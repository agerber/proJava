
      ___            ___        /  /\         /  /\         /  /\    
     /  /\          /__/\      /  /::\       /  /::\       /  /::\   
    /  /:/          \__\:\    /  /:/\:\     /  /:/\:\     /  /:/\:\  
   /  /:/           /  /::\  /  /:/  \:\   /  /::\ \:\   /  /:/  \:\ 
  /__/:/  ___    __/  /:/\/ /__/:/ \__\:| /__/:/\:\ \:\ /__/:/ \__\:\
  |  |:| /  /\  /__/\/:/~~  \  \:\ /  /:/ \  \:\ \:\_\/ \  \:\ /  /:/
  |  |:|/  /:/  \  \::/      \  \:\  /:/   \  \:\ \:\    \  \:\  /:/ 
  |__|:|__/:/    \  \:\       \  \:\/:/     \  \:\_\/     \  \:\/:/  
   \__\::::/      \__\/        \__\::/       \  \:\        \  \::/   
       ~~~~                        ~~         \__\/         \__\/    
      ___           ___           ___           ___     
     /  /\         /  /\         /  /\         /  /\    
    /  /::\       /  /::\       /  /::|       /  /::\   
   /  /:/\:\     /  /:/\:\     /  /:|:|      /  /:/\:\  
  /  /:/  \:\   /  /::\ \:\   /  /:/|:|__   /  /::\ \:\ 
 /__/:/_\_ \:\ /__/:/\:\_\:\ /__/:/_|::::\ /__/:/\:\ \:\
 \  \:\__/\_\/ \__\/  \:\/:/ \__\/  /~~/:/ \  \:\ \:\_\/
  \  \:\ \:\        \__\::/        /  /:/   \  \:\ \:\  
   \  \:\/:/        /  /:/        /  /:/     \  \:\_\/  
    \  \::/        /__/:/        /__/:/       \  \:\    
     \__\/         \__\/         \__\/         \__\/    




Create a classic video game using the tools you've learned throughout the quarter.
1/ You MUST extend the Asteroids code-base provided to you.
2/ You can create any video game you want, EXCEPT Asteroids.
3/ You may code your game in either Java or Kotlin; see README.md of proJava for Kotlin instructions.
4/ You may use up to (but no more than) 40% found-code, so long as you cite the source in your java source files.
My code (the game base) is yours, and not considered found-code. Github is a good resource for 2D Java games from which
to draw inspiration.

This game uses both vector and raster graphics.
The advantage of vector graphics is that they scale infinitely, and they render extremely fast. If you use
raster graphics (png's, jpg's, etc) which are essentially two-dimensional grids of pixels, make sure to reduce
 the pixel density, otherwise your game will lag when rendering. For
 raster graphics implementation, see the Falcon or WhiteCloudDebris classes.

In order to extend the game code provided to you, there are some traps you should avoid:

1/ Do not attempt to do colission detection in any other way than what is already implemented for you with circles; and
that means do NOT attempt to detect the intersection of two polygons or even two rectangle objects. Your sprites should
be effectively a shape with equal width and height circumscribed by a circle.

2/ Start with the Asteroids game and make incremental changes to it. You will avoid a lot of problems using
this approach. Your game should not stray too far from Asteroids.  Games like
1941, Joust, Galaga, Sinistar, Space Invaders, Missile Command, are good. Do not try to create a game that
requires a grid like tetris, break-out, pong, pac-man, etc.

The TAs will select the top ten games. The ten finalists will demonstrate their games and present their code and
architecture, and the class will vote on the best game. The winner will receive a token prize during an
awards-ceremony on the last day.

**************************************************
**************************************************
**************************************************

Some things to keep in mind.

1/ Sprite is essentially a shape circumscribed by a circle, which makes collision detection really easy. If you use
vector graphics, you will create your polygons as a series of adjacent cartesian vertices on a grid with 0,0 at the
origin. When you add your points to the ArrayList, order matters, so that each point is adjacent to its neighbor in the
 List. The following List<Point> describes the shape of the fictitious vector Sprite. Just keep in mind that
 creating this List<Point> out-of-order will produce a jaggedy-shaped sprite. The following order is correct
 (though I could have traversed the points counter-clockwise with the same good result). See Bullet or NewShipFloater
 classes to see how to create carteseans.


		List<Point> pntList = new ArrayList<Point>();
		pntList.add(new Point(0, 5)); //top point
		pntList.add(new Point(1, 3));  //right top point
		pntList.add(new Point(1, -2)); //right bottom point
		pntList.add(new Point(-1, -2)); // left bottom point
		pntList.add(new Point(-1, 3)); //left top point




Some addition info:
the M key is for muting music. 

